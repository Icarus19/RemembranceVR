// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel BoidPositions
#include <UnityShaderVariables.cginc>

struct BoidData
{
    float3 position;
    float3 initialPosition;
    float oscillationOffset;
    float size;
};
struct PosData
{
    float3 CollisionPos;
    float3 DefaultPos;
};

float3 _CorePos;
float3 _AvoidPosition;
float3 _PreviousAvoidPosition;
float _SpinSpeed;
float _OscillationSpeed;
float _OscillationMagnitude;
float _AvoidDistance;
float _AvoidStrength;
float _AvoidLerpSpeed;
bool _CollisionDetected;

RWStructuredBuffer<BoidData> _BoidBuffer;
RWStructuredBuffer<PosData> _PreviousPositionBuffer;

float Rand(uint3 id)
{
    return frac(sin(dot(float2(id.x, id.y), float2(12.9898, 78.233))) * 43758.5453);
}

// Rotate vector by axis using angle
float3 RotateAroundAxis(float3 position, float3 axis, float angle)
{
    float cosAngle = cos(angle);
    float sinAngle = sin(angle);

    // Rotation matrix components
    float3 xAxis = axis.x * axis;
    float3 yAxis = axis.y * axis;
    float3 zAxis = axis.z * axis;

    // Rotation matrix
    float3 rotatedPosition = cosAngle * position + sinAngle * cross(axis, position) + (1.0 - cosAngle) * dot(axis, position) * axis;

    return rotatedPosition;
}

[numthreads(1024,1,1)]
void BoidPositions (uint3 id : SV_DispatchThreadID)
{
    //Retrieve boid data
    BoidData boid = _BoidBuffer[id.x];

    //Calculate distance from core
    float dst = distance(boid.initialPosition, _CorePos);

    // Calculate spin data
    float time = _Time.y;
    float spinSpeed = _SpinSpeed / (dst + 0.01);
    float angle = spinSpeed * time;
    float oscillation = 1.0 + sin(time * _OscillationSpeed + boid.oscillationOffset) * _OscillationMagnitude;
    
    //Rotate around random axis
    float3 randomAxis = normalize(float3(Rand(id), Rand(id + uint3(1, 0, 0)), Rand(id + uint3(0, 1, 0))));
    float3 rotatedPos = RotateAroundAxis(boid.initialPosition, randomAxis, angle);

    //Apply oscillation
    rotatedPos *= oscillation;

    //Updated particle writeback
    boid.position = rotatedPos + _CorePos;

    //Retrieve BufferData
    float3 previousPositionBuffer = _PreviousPositionBuffer[id.x].CollisionPos;
    float3 defaultPositionBuffer = _PreviousPositionBuffer[id.x].DefaultPos;

    //Smooth transition from avoidancePoint
    previousPositionBuffer = lerp(previousPositionBuffer, _AvoidPosition, _AvoidLerpSpeed);

    //Updatebuffer with transition POSITION
    _PreviousPositionBuffer[id.x].CollisionPos = previousPositionBuffer;

    //Apply smooth avoidance force
    float3 offset = boid.position - previousPositionBuffer;
    float sqrDst = dot(offset, offset);

    float distance = sqrt(sqrDst);
    float strength = (_AvoidDistance - distance) / _AvoidDistance;
    strength = saturate(strength) * _AvoidStrength;
    
    //Normalize offset and apply force
    float3 avoidanceForce = normalize(offset) * strength;

    //If no collision gradually apply no force //I'm confused wouldn't this be the opposit? but it still works
    if(_CollisionDetected)
    {
        defaultPositionBuffer = lerp(defaultPositionBuffer, avoidanceForce, _AvoidLerpSpeed);
    }
    _PreviousPositionBuffer[id.x].DefaultPos = defaultPositionBuffer;
    
    //Smoothley steer away from object
    boid.position += defaultPositionBuffer;

    _BoidBuffer[id.x] = boid;
}
